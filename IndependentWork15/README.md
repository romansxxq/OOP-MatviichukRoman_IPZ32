# Звіт з аналізу SOLID принципів (SRP, OCP) в Open-Source проєкті
## 1. Обраний проєкт
- **Назва:** eShopOnWeb
- **Посилання на GitHub:** https://github.com/dotnet-architecture/eShopOnWeb.git
## 2. Аналіз SRP (Single Responsibility Principle)
### 2.1. Приклади дотримання SRP
#### Клас: `Basket`
- **Відповідальність:** Управління внутрішнім станом кошика та забезпечення цілісності бізнес-логіки додавання товарів.
- **Обґрунтування:** Клас чітко дотримується принципу єдиної відповідальності, оскільки він займається виключно логікою поведінки сутності.

1. **Інкапсуляція даних:** Список `_items` є приватним (private). Ніхто ззовні (наприклад, Контролер) не може просто взяти і очистити кошик або додати туди некоректний товар напряму. Вони змушені використовувати методи класу Basket.

2. **Ізольована логіка:** Метод AddItem містить логіку перевірки: "Якщо товар вже є — збільши кількість, якщо немає — додай новий". Це бізнес-правило, і воно живе саме тут, а не розмазане по сервісах.

3. **Відсутність зайвого:** Клас не знає про базу даних (SQL), не знає про інтерфейс користувача (HTML) і не відправляє емейли.
```csharp
public class Basket : BaseEntity, IAggregateRoot
{
    // SRP: Стан захищений. Ззовні цей список змінити не можна, тільки читати.
    private readonly List<BasketItem> _items = new List<BasketItem>();
    public IReadOnlyCollection<BasketItem> Items => _items.AsReadOnly();

    public void AddItem(int catalogItemId, decimal unitPrice, int quantity = 1)
    {
        // SRP: Вся логіка "як правильно додати товар" знаходиться ВНУТРІШНІ.
        // Якщо правило зміниться (наприклад, макс. 10 товарів),
        // ми змінимо лише цей метод.
        if (!Items.Any(i => i.CatalogItemId == catalogItemId))
        {
            _items.Add(new BasketItem(catalogItemId, quantity, unitPrice));
            return;
        }
        
        // Логіка оновлення існуючого товару теж тут
        var existingItem = Items.First(i => i.CatalogItemId == catalogItemId);
        existingItem.AddQuantity(quantity);
    }
}
``` 
#### Клас: `OrderService`
```csharp
public async Task CreateOrderAsync(int basketId, Address shippingAddress)
{
    // SRP: Отримання даних делеговано репозиторію
    var basket = await _basketRepository.FirstOrDefaultAsync(basketSpec);

    // SRP: Валідація делегована класу Guard (бібліотека Ardalis.GuardClauses)
    Guard.Against.Null(basket, nameof(basket));
    Guard.Against.EmptyBasketOnCheckout(basket.Items);

    // SRP: Логіка формування URL делегована _uriComposer
    // ... _uriComposer.ComposePicUri(...)
    
    // SRP: Створення сутності делеговано конструктору Order
    var order = new Order(basket.BuyerId, shippingAddress, items);

    await _orderRepository.AddAsync(order);
}
```
- Відповідальність: Оркестрація (координація) процесу створення замовлення з існуючого кошика.

- **Обґрунтування:** Цей клас є чудовим прикладом того, як сервіс не намагається робити все сам, а делегує роботу іншим спеціалізованим класам. Він діє як "диригент":

1. *Делегування валідації:* Замість того, щоб писати if (basket == null) throw ..., він використовує Guard.Against, делегуючи перевірку окремому механізму.

2. Делегування доступу до даних: Він не пише SQL-запити. Він просить _basketRepository та _itemRepository дати дані.

3. Делегування бізнес-логіки: Він не розраховує структуру замовлення вручну, а створює сутність new Order(...), яка сама знає, як себе побудувати.

4. Делегування роботи з шляхами: Формування URL картинки віддано _uriComposer.

Якщо зміниться логіка збереження в БД — ми змінимо Репозиторій. Якщо зміниться логіка валідації — ми змінимо Guard. OrderService змінюється лише тоді, коли змінюється сам процес перетворення кошика в замовлення.

### 2.2. Приклади порушення SRP
Клас: [Назва Класу 3]
• Множинні відповідальності: [Опис]
• Проблеми: [Які проблеми це викликає]
// Фрагмент коду
## 3. Аналіз OCP (Open/Closed Principle)
### 3.1. Приклади дотримання OCP
Сценарій/Модуль: [Назва Сценарію 1]
• Механізм розширення: [Інтерфейси, абстрактні класи, патерни]
• Обґрунтування: [Як дозволяє розширювати без модифікації]
// Фрагмент коду
Сценарій/Модуль: [Назва Сценарію 2]
• ...
### 3.2. Приклади порушення OCP
Сценарій/Модуль: [Назва Сценарію 3]
• Проблема: [Як порушується OCP]
• Наслідки: [Які проблеми це викликає]
// Фрагмент коду
4. Загальні висновки
[Ваші загальні висновки щодо застосування SRP та OCP в обраному проєкті] “‘