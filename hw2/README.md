# Домашня робота №2
## Тема: LSP: приклади порушень

Принцип LSP говорить, що об’єкти підкласу повинні без проблем замінювати об’єкти базового класу, не змінюючи коректність роботи програми.
Нижче наведено 3 приклади порушення LSP.
## Приклад №1
```csharp
class Bird
{
    public virtual void Fly()
    {
        Console.WriteLine("Птах летить");
    }
}

class Penguin : Bird
{
    public override void Fly()
    {
        throw new NotSupportedException("Пінгвіни не літають");
    }
}
```
## Опис проблеми
Є базовий клас `Bird`, який має метод `Fly()`.
Клас Penguin наслідується від Bird, але пінгвіни літати не вміють.

### Чому це порушує LSP?
Якщо у програмі очікується об’єкт `Bird` і викликається метод `Fly()`, то підстановка Penguin призведе до:
- винятку;
- порожньої реалізації;
- або некоректної поведінки.

Це означає, що підклас не може повноцінно замінити базовий клас.
### Проблеми
- неочікувані помилки під час виконання;
- перевірки типів `(if (bird is Penguin))`, що порушує чистоту коду.
### Перепроєктування
```csharp
interface IFlyable
{
    void Fly();
}
```
- винести поведінку польоту в окремий інтерфейс IFlyable;
- Eagle реалізує IFlyable, а Penguin - ні.

## Приклад №2
```csharp
class Account
{
    public virtual void Withdraw(decimal amount)
    {
        Console.WriteLine($"Знято {amount} грн");
    }
}

class ReadOnlyAccount : Account
{
    public override void Withdraw(decimal amount)
    {
        throw new InvalidOperationException("Зняття коштів заборонене");
    }
}
```
### Опис проблеми
Є клас Account з методом `Withdraw()`.
Підклас `ReadOnlyAccount` забороняє зняття коштів.

### Чому це порушує LSP?
Код, який працює з Account, очікує, що `Withdraw()` завжди доступний. Але при підстановці ReadOnlyAccount:
- метод кидає виняток;
- або нічого не робить.

Це змінює очікувану поведінку.

### Проблеми
- логіка програми ламається;
- клієнтський код змушений враховувати конкретні реалізації.
### Перепроєктування
- розділити інтерфейси: `IReadableAccount`, `IWithdrawableAccount`
використовувати лише потрібний контракт.
## Приклад №3
### Опис проблеми
Базовий клас `Document` має метод `Save()`.
`ReadOnlyDocument` перевизначає його та кидає виняток.
### Чому це порушує LSP?
Код, який працює з `Document`, логічно очікує можливість збереження.
Підстановка `ReadOnlyDocument` порушує цей контракт.
### Проблеми
- помилки під час виконання;
- порушення довіри до базового типу.
### Перепроєктування
розділити обов’язки:
- `ReadableDocument`
- `WritableDocument`
або винести збереження в окремий сервіс.
## Висновок
Порушення LSP зазвичай виникає тоді, коли:
- підклас обмежує поведінку базового класу;
- або змінює очікуваний контракт.

Щоб дотримуватися LSP, варто:
- використовувати інтерфейси;
- не змушувати підкласи підтримувати зайву поведінку;
- проєктувати ієрархії на основі поведінки, а не лише назв класів.